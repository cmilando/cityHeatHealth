}
if(verbose > 0) {
cat("-- run STAN\n")
}
# Note: Be REALLY careful about the data types here
stan_data <- list(
J = as.integer(J),  # integer
Jmat = Jmat,        # matrix so you can do math on it
N = as.integer(N),
K = as.integer(K),
X = X,              # matrix so you can do math
y = y,
S = S,              # matrix so you can do math on it
n_strata = n_strata,
max_in_strata = max_in_strata,
S_condensed = S_condensed,
stratum_id = stratum_id
)
K
# Note: Be REALLY careful about the data types here
stan_data <- list(
J = as.integer(J),  # integer
Jmat = Jmat,        # matrix so you can do math on it
N = as.integer(N),
K = as.integer(K),
X = X,              # matrix so you can do math
y = y,
S = S,              # matrix so you can do math on it
n_strata = n_strata,
max_in_strata = max_in_strata,
S_condensed = S_condensed,
stratum_id = stratum_id
)
# from here https://github.com/rok-cesnovar/misc/blob/master/democmdstanr/R/bernoulli.R
# and here https://discourse.mc-stan.org/t/r-package-using-cmdstanr/32758
stan_file <- system.file("stan", "SB_CondPoisson.stan",
package = "cityHeatHealth")
mod <- cmdstanr::cmdstan_model(stan_file,
cpp_options = list(stan_threads = TRUE))
# could try it this way
out2_var <- mod$variational(
data = stan_data,
iter = 10000,
refresh = 10
)
# could try it this way
out2_var <- mod$variational(
data = stan_data,
iter = 10000,
refresh = 10,
threads = 2
)
# and then finally the draws etc
out2 <- out2_var
out2_data <- posterior::as_draws_df(out2$draws())
setDT(out2_data)
beta_reg_all <- out2_data[, .SD, .SDcols = patterns("^beta_out")]
beta_reg_all <- apply(beta_reg_all, 2, mean)
beta_mat <- matrix(beta_reg_all, nrow = K, ncol = J, byrow = F)
beta_mat[, 1:5]
beta_mat
coef_list   <- vector("list", n_geos);
# loop through geos
for(i in 1:n_geos) {
# get the name, which you know exists in both datasets
this_geo <- unique_geos[i, get(outcome_columns$geo_unit)]
if(verbose > 1) {
cat(this_geo, '\t')
}
# this cities exposure matrix
rr <- exposure_matrix[, get(exp_geo_unit_col)] == this_geo
single_exposure_matrix = exposure_matrix[rr, ,drop = FALSE]
this_exp <- single_exposure_matrix[, get(exposure_columns$exposure)]
x_b <- c(floor(min(this_exp)), ceiling(max(this_exp)))
rr <- outcomes_tbl[, get(out_geo_unit_col)] == this_geo
single_outcomes_tbl = outcomes_tbl[rr, ,drop = FALSE]
# run the model once
# just using this to get cb so i don't repeat that code twice
# because it also has a lot of nice validation built into it
# min_n is set to 0 because you want every region
# same with strata_min
local_cp <- condPois_single(exposure_matrix = single_exposure_matrix,
outcomes_tbl = single_outcomes_tbl,
argvar = argvar, arglag = arglag,
maxlag = maxlag, min_n = 1,
strata_min = 0)
blup_cp <- get_centered_cp(argvar = local_cp$argvar,
xcoef = local_cp$cr_coef,
xvcov = local_cp$cr_vcov,
global_cen = global_cen,
cen = local_cp$cen,
this_exp = this_exp,
x_b = x_b)
# get cb and outcomes lists
coef_list[[i]]   <- local_cp$cr_coef
cb_list[[i]]     <- blup_cp$basis_cen
outc_list[[i]]   <- single_outcomes_tbl
cen_list[[i]]    <- local_cp$cen
argvar_list[[i]] <- local_cp$argvar
rm(local_cp)
}
coef_list
coef_list
beta_mat
t(beta_mat)
do.call(rbind, coef_list)
# MCMC -- Much longer, especially for things with lags
#         wait ..... can  you do this just on the crossreduce though ...
#         why do you need to do this on
out2_mcmc <- mod$sample(
data = stan_data,
chains = 2,
iter_warmup = 3000,
iter_sampling = 5000,
parallel_chains = 2,
threads_per_chain = 1,
refresh = 10,
#adapt_delta = 0.8,
max_treedepth = 7 # .... ?
)
# MCMC -- Much longer, especially for things with lags
#         wait ..... can  you do this just on the crossreduce though ...
#         why do you need to do this on
out2_mcmc <- mod$sample(
data = stan_data,
chains = 2,
#iter_warmup = 3000,
#iter_sampling = 5000,
parallel_chains = 2,
#threads_per_chain = 1,
refresh = 10,
#adapt_delta = 0.8,
max_treedepth = 7 # .... ?
)
# MCMC -- Much longer, especially for things with lags
#         wait ..... can  you do this just on the crossreduce though ...
#         why do you need to do this on
out2_mcmc <- mod$sample(
data = stan_data,
chains = 2,
#iter_warmup = 3000,
#iter_sampling = 5000,
parallel_chains = 2,
threads_per_chain = 1,
refresh = 10,
#adapt_delta = 0.8,
max_treedepth = 7 # .... ?
)
# and then finally the draws etc
out2 <- out2_mcmc
out2_data <- posterior::as_draws_df(out2$draws())
setDT(out2_data)
beta_reg_all <- out2_data[, .SD, .SDcols = patterns("^beta_out")]
beta_reg_all <- apply(beta_reg_all, 2, mean)
beta_mat <- matrix(beta_reg_all, nrow = K, ncol = J, byrow = F)
# with spatial smoothing
t(beta_mat)
# without spatial smoothing
do.call(rbind, coef_list)
Jmat
duplicated(Jmat)
# 1st-order neighbors
nb1 <- poly2nb(shp_sf_safe)
# 2nd-order neighbors (neighbors of neighbors)
nb2 <- nblag(nb1, 2)
# Combine 1st + 2nd order neighbors
nb12 <- nb1
for (i in seq_along(nb12)) {
nb12[[i]] <- sort(unique(unlist(nb2[[i]])))
}
# Convert to weights
list_neig <- nb2listw(nb12, zero.policy = TRUE)
# 2nd-order neighbors (neighbors of neighbors)
nb_lags <- nblag(nb1, 2)
nb12 <- nb1
for (i in seq_along(nb12)) {
nb12[[i]] <- sort(unique(c(
nb_lags[[1]][[i]],
nb_lags[[2]][[i]]
)))
}
list_neig <- nb2listw(nb12, zero.policy = TRUE)
stopifnot(all(dim(list_neig)))
list_neig
neighbors <- lapply(list_neig$neighbours,c)
neighbors
# 2nd-order neighbors (neighbors of neighbors)
nb_lags <- nblag(nb1, 2)
nb_lags
nb12 <- nb1
for (i in seq_along(nb12)) {
nb12[[i]] <- list(n1 = nb_lags[[1]][[i]],
n2 = nb_lags[[2]][[i]])
}
nb12
nb12 <- vector("list", n_geos)
for (i in seq_along(nb12)) {
nb12[[i]] <- list(n1 = nb_lags[[1]][[i]],
n2 = nb_lags[[2]][[i]])
}
nb12
shp_sf$county_ID <- 1:nrow(shp_sf)
ggplot(shp_sf_ct) + geom_sf(aes(fill = factor(county_ID)))
shp_sf$county_ID <- 1:nrow(shp_sf)
ggplot(shp_sf) + geom_sf(aes(fill = factor(county_ID)))
ggplot(shp_sf) + geom_sf(aes(fill = factor(county_ID)))
ggplot(shp_sf) + geom_sf(aes(fill = factor(county_ID)))
nb12
list_neig <- nb2listw(nb12, zero.policy = TRUE)
j = 1
n1 = nb_lags[[1]][[i]]
n2 = nb_lags[[2]][[i]]
n1
Jmat <- matrix(0, nrow = J, ncol = J)
if(j > 1) {
for(j in 1:J) {
n1 = nb_lags[[1]][[i]]
n2 = nb_lags[[2]][[i]]
Jmat[j, n1] <- 1
Jmat[j, n2] <- 0.5
}
}
Jmat
Jmat <- matrix(0, nrow = J, ncol = J)
if(j > 1) {
for(j in 1:J) {
n1 = nb_lags[[1]][[j]]
n2 = nb_lags[[2]][[j]]
Jmat[j, n1] <- 1
Jmat[j, n2] <- 0.5
}
}
Jmat
nb_lags[[1]][[j]]
J
Jmat <- matrix(0, nrow = J, ncol = J)
if(j > 1) {
for(j in 1:J) {
n1 = nb_lags[[1]][[j]]
n2 = nb_lags[[2]][[j]]
Jmat[j, n1] <- 1
Jmat[j, n2] <- 0.5
}
}
Jmat
j = 1
n1 = nb_lags[[1]][[j]]
n2 = nb_lags[[2]][[j]]
n1
n2
Jmat[j, n1]
Jmat[j, n1] <- 1
Jmat[j, n2]
n2
Jmat[j, n2] <- 0.5
Jmat
j = 2
n1 = nb_lags[[1]][[j]]
n2 = nb_lags[[2]][[j]]
n1
n2
Jmat[j, n1] <- 1
Jmat
Jmat[j, n2] <- 0.5
Jmat
for(j in 1:J) {
print(j)
n1 = nb_lags[[1]][[j]]
n2 = nb_lags[[2]][[j]]
n1
n2
Jmat[j, n1] <- 1
Jmat[j, n2] <- 0.5
}
Jmat
Jmat <- matrix(0, nrow = J, ncol = J)
if(j > 1) {
for(j in 1:J) {
print(j)
n1 = nb_lags[[1]][[j]]
n2 = nb_lags[[2]][[j]]
n1
n2
Jmat[j, n1] <- 1
Jmat[j, n2] <- 0.5
}
}
Jmat
Jmat <- matrix(0, nrow = J, ncol = J)
if(j > 1) {
for(j in 1:J) {
print(j)
n1 = nb_lags[[1]][[j]]
n2 = nb_lags[[2]][[j]]
n1
n2
Jmat[j, n1] <- 1
Jmat[j, n2] <- 1
}
}
Jmat
if(verbose > 0) {
cat("-- run STAN\n")
}
# Note: Be REALLY careful about the data types here
stan_data <- list(
J = as.integer(J),  # integer
Jmat = Jmat,        # matrix so you can do math on it
N = as.integer(N),
K = as.integer(K),
X = X,              # matrix so you can do math
y = y,
S = S,              # matrix so you can do math on it
n_strata = n_strata,
max_in_strata = max_in_strata,
S_condensed = S_condensed,
stratum_id = stratum_id
)
# from here https://github.com/rok-cesnovar/misc/blob/master/democmdstanr/R/bernoulli.R
# and here https://discourse.mc-stan.org/t/r-package-using-cmdstanr/32758
stan_file <- system.file("stan", "SB_CondPoisson.stan",
package = "cityHeatHealth")
mod <- cmdstanr::cmdstan_model(stan_file,
cpp_options = list(stan_threads = TRUE))
# (1) Variational
out2_var <- mod$variational(
data = stan_data,
iter = 10000,
refresh = 10,
threads = 2
)
# and then finally the draws etc
out2 <- out2_var
out2_data <- posterior::as_draws_df(out2$draws())
setDT(out2_data)
beta_reg_all <- out2_data[, .SD, .SDcols = patterns("^beta_out")]
beta_reg_all <- apply(beta_reg_all, 2, mean)
beta_mat <- matrix(beta_reg_all, nrow = K, ncol = J, byrow = F)
# with spatial smoothing
t(beta_mat)
# without spatial smoothing
do.call(rbind, coef_list)
# MCMC -- Much longer, especially for things with lags
#         wait ..... can  you do this just on the crossreduce though ...
#         why do you need to do this on
out2_mcmc <- mod$sample(
data = stan_data,
chains = 2,
#iter_warmup = 3000,
#iter_sampling = 5000,
parallel_chains = 2,
threads_per_chain = 1,
refresh = 10,
#adapt_delta = 0.8,
#max_treedepth = 7 # .... ?
)
usethis::use_vignette("one_stage_demo", "Estimating region-wide heat-health impacts in `cityHeatHealth`")
print
#' ////////////////////////////////////////////////////////////////////////////
#' ============================================================================
#' COMPARE
#' ============================================================================
#' #' /////////////////////////////////////////////////////////////////////////
library(dlnm)
library(splines)
library(rstan)
library(cmdstanr)
library(tidyverse)
library(foreign) # ENABLES READING THE DATA FILE, WHICH IS A STATA FORMAT
data <- read.dta("https://raw.github.com/gasparrini/2014_armstrong_BMCmrm_codedata/master/londondataset2002_2006.dta")
dlnm_var <- list(
var_prc = c(0.50, 0.90),
var_fun = "ns",
max_lag = 8,
lagnk = 2)
# SET THE DEFAULT ACTION FOR MISSING DATA TO na.exclude
# (MISSING EXCLUDED IN ESTIMATION BUT RE-INSERTED IN PREDICTION/RESIDUALS)
options(na.action = "na.exclude")
# SCALE EXPOSURE
data$ozone10 <- data$ozone / 10
# GENERATE MONTH AND YEAR
# changed the factor part here so it wouldn't carry forwards
# subset to reduce the no. of factors
data$month <- months(data$date)
data$year <- format(data$date, format = "%Y")
data$dow <- weekdays(data$date)
# make lags
data$lag1 <- lag(data$temperature, 1)
data$lag2 <- lag(data$temperature, 2)
data$lag3 <- lag(data$temperature, 3)
data$lag4 <- lag(data$temperature, 4)
data$lag5 <- lag(data$temperature, 5)
data$lag6 <- lag(data$temperature, 6)
data$lag7 <- lag(data$temperature, 7)
data$lag8 <- lag(data$temperature, 8)
# SUBSET TO SUMMER
data <- subset(data, month %in% c("May", 'June', 'July', 'August', 'September'))
# subset for Excel application
data$stratum <- interaction(data$year, data$month, data$dow)
data$stratum
data <- data[order(data$date), ]
# create S matrix
getSmat <- function(strata_vector) {
# strata_vector <- data$stratum
strata_matrix <- matrix(as.integer(strata_vector),
nrow = length(strata_vector),
ncol = length(strata_vector),
byrow = T)
for(i in 1:length(strata_vector)) {
strata_matrix[i, ] = 1*(strata_matrix[i, ] == as.integer(strata_vector[i]))
}
return(strata_matrix)
}
temp <- data[, c("temperature", paste0("lag", 1:dlnm_var$max_lag))]
temp_knots <- quantile(temp$temperature, dlnm_var$var_prc, na.rm = TRUE)
temp_boundary <- range(temp, na.rm = TRUE)
cb.temp <- crossbasis(temp,
argvar = list(fun = dlnm_var$var_fun,
knots = temp_knots,
Boundary.knots = temp_boundary),
arglag = list(fun = "ns",
knots = logknots(dlnm_var$max_lag,
dlnm_var$lagnk),
intercept = TRUE))
# FIT UNCONDITIONAL POISSON MODEL
model_upr <- glm(numdeaths ~ cb.temp + factor(stratum),
data = data, family = quasipoisson)
coef(model_upr)[2:13]
cp1 <- crosspred(cb.temp, model_upr)
plot(cp1, 'overall')
# FIT A CONDITIONAL POISSON MODEL WITH A YEAR X MONTH X DOW STRATA
library(gnm)
df_keep <- data %>%
group_by(stratum) %>%
summarize(
.groups = 'keep',
sum_deaths = sum(numdeaths)
) %>%
mutate(keep  = 1)
data <- left_join(data, df_keep)
library(gnm)
modelcpr1 <- gnm(numdeaths ~  cb.temp,
data = data, family = quasipoisson,
eliminate = factor(stratum),
subset = keep == 1)
cp2 <- crosspred(cb.temp, modelcpr1)
plot(cp2, 'overall')
cbind("normal" = coef(model_upr)[2:13],
"conditional" = coef(modelcpr1))
# yeah this is the one
# https://mc-stan.org/docs/2_20/functions-reference/multinomial-distribution.html
#
#' ////////////////////////////////////////////////////////////////////////////
#' ============================================================================
#' SETUP inputs
#' ============================================================================
#' #' /////////////////////////////////////////////////////////////////////////
J = as.integer(1)
# nrows
N = as.integer(nrow(data))
# beta and the intercept
K = as.integer(ncol(cb.temp))
# include the intercept
X = array(dim = c(dim(as.matrix(cb.temp)), J))
X[,,1] <- as.matrix(cb.temp)
# outcome
y1 = as.integer(data$numdeaths)
y = as.matrix(y1, ncol = 1)
#
S <- getSmat(data$stratum)
# get strata vars
n_strata <- as.integer(length(unique(data$stratum))) # 72, cool
S_list <- apply(S, 1, function(x) which(x == 1))
max_in_strata <- max(sapply(S_list, length))
S_list <- lapply(S_list, function(l) {
if(length(l) == max_in_strata) {
return(l)
} else {
diff_n = max_in_strata - length(l)
return(c(l, rep(0, times = diff_n)))
}
})
S_condensed <- unique(do.call(rbind, S_list))
dim(S_condensed)
#
stratum_id = as.integer(factor(data$stratum))
stratum_id
## *** THIS BECOMES THE J MATRIX
Jmat <- matrix(0, nrow = 1, ncol = 1)
Jmat
#' ////////////////////////////////////////////////////////////////////////////
#' ============================================================================
#' SETUP inputs
#' ============================================================================
#' #' /////////////////////////////////////////////////////////////////////////
stan_data <- list(
J = J,
Jmat = Jmat,
N = N,
K = K,
X = X,
y = y,
S = S,
n_strata = n_strata,
max_in_strata = max_in_strata,
S_condensed = S_condensed,
stratum_id = stratum_id,
grainsize = as.integer(3)
)
# Set path to model
stan_model <- cmdstan_model("CondPoisson_1d.stan",
cpp_options = list(stan_threads = TRUE))
