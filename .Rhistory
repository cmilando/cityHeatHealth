## natural spline
## two knots
argvar <- list(fun = arg_fun, knots = x_knots)
arglag <- list(fun = lag_fun, knots = dlnm::logknots(maxlag, nk = nk))
# keep only the columns you need
x_mat <- boston_exposure_mat[, c('tmax_C', paste0('Templag',1:maxlag))]
cb <- crossbasis(x_mat, lag = maxlag, argvar = argvar, arglag = arglag)
##
boston_deaths$dow   <- lubridate::wday(boston_deaths$date, label = T)
boston_deaths$month <- lubridate::month(boston_deaths$date, label = T)
boston_deaths$year  <- lubridate::year(boston_deaths$date)
boston_deaths$strata <- paste0(boston_deaths$TOWN20, ":",
boston_deaths$year, ":",
boston_deaths$month, ":",
boston_deaths$dow)
## get rid of 0 strata
## you make sure there are no empty strata
boston_deaths_agg <- boston_deaths %>%
group_by(strata) %>%
summarize(
.groups = 'keep',
total_daily_deaths = sum(daily_deaths)
) %>%
mutate(keep = ifelse(total_daily_deaths > 0, 1, 0))
boston_deaths_comb <- left_join(boston_deaths,
boston_deaths_agg,
by = join_by(strata))
head(boston_deaths_comb)
library(gnm)
m_sub <- gnm(daily_deaths ~ cb,
data = boston_deaths_comb,
family = quasipoisson,
eliminate = factor(strata),
subset = keep == 1)
cp <- dlnm::crosspred(cb, m_sub, by = 0.1)
cen = cp$predvar[which.min(cp$allRRfit)]
cp <- dlnm::crosspred(cb, m_sub, cen = cen, by = 0.1)
dlnm::plot.crosspred(cp, "overall")
m1 <- single_zone(exposure_matrix = boston_exposure_mat, outcomes = boston_deaths,
argvar = argvar, arglag = arglag, maxlag = maxlag)
devtools::document()
devtools::load_all()
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(cityHeatHealth)
boston_exposure <- subset(ma_exposure, TOWN20 == 'BOSTON')
head(boston_exposure)
boston_exposure_mat <- make_exposure_matrix(boston_exposure)
head(boston_exposure_mat)
boston_deaths   <- subset(ma_deaths, TOWN20 == 'BOSTON')
head(boston_deaths)
## inputs
arg_fun = 'ns'
lag_fun = 'ns'
x_knots = quantile(boston_exposure_mat$tmax_C, probs = c(0.5, 0.9))
maxlag = 5
nk = 2
## natural spline
## two knots
argvar <- list(fun = arg_fun, knots = x_knots)
arglag <- list(fun = lag_fun, knots = dlnm::logknots(maxlag, nk = nk))
# keep only the columns you need
x_mat <- boston_exposure_mat[, c('tmax_C', paste0('Templag',1:maxlag))]
cb <- crossbasis(x_mat, lag = maxlag, argvar = argvar, arglag = arglag)
##
boston_deaths$dow   <- lubridate::wday(boston_deaths$date, label = T)
boston_deaths$month <- lubridate::month(boston_deaths$date, label = T)
boston_deaths$year  <- lubridate::year(boston_deaths$date)
boston_deaths$strata <- paste0(boston_deaths$TOWN20, ":",
boston_deaths$year, ":",
boston_deaths$month, ":",
boston_deaths$dow)
## get rid of 0 strata
## you make sure there are no empty strata
boston_deaths_agg <- boston_deaths %>%
group_by(strata) %>%
summarize(
.groups = 'keep',
total_daily_deaths = sum(daily_deaths)
) %>%
mutate(keep = ifelse(total_daily_deaths > 0, 1, 0))
boston_deaths_comb <- left_join(boston_deaths,
boston_deaths_agg,
by = join_by(strata))
head(boston_deaths_comb)
library(gnm)
m_sub <- gnm(daily_deaths ~ cb,
data = boston_deaths_comb,
family = quasipoisson,
eliminate = factor(strata),
subset = keep == 1)
cp <- dlnm::crosspred(cb, m_sub, by = 0.1)
cen = cp$predvar[which.min(cp$allRRfit)]
cp <- dlnm::crosspred(cb, m_sub, cen = cen, by = 0.1)
dlnm::plot.crosspred(cp, "overall")
m1 <- single_zone(exposure_matrix = boston_exposure_mat,
outcomes = boston_deaths)
plot(m1, 'overall')
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
cp <- crosspred(cb, m_sub, cen = 20, by = 0.1)
cen = cp$predvar[which.min(cp$allRRfit)]
cp <- crosspred(cb, m_sub, cen = cen, by = 0.1)
plot_cp = data.frame(
x = cp$predvar,
RR = cp$allRRfit,
RRlow = cp$allRRlow,
RRhigh = cp$allRRhigh
)
ggplot(plot_cp, aes(x = x, y = RR, ymin = RRlow, ymax = RRhigh)) +
geom_hline(yintercept = 1, linetype = '11') +
theme_classic() +
geom_ribbon(fill = 'grey75', alpha = 0.2) +
geom_line()
library(dlnm)
library(dplyr)
library(lubridate)
library(gnm)
library(ggplot2)
cp <- crosspred(cb, m_sub, cen = 20, by = 0.1)
cen = cp$predvar[which.min(cp$allRRfit)]
cp <- crosspred(cb, m_sub, cen = cen, by = 0.1)
plot_cp = data.frame(
x = cp$predvar,
RR = cp$allRRfit,
RRlow = cp$allRRlow,
RRhigh = cp$allRRhigh
)
ggplot(plot_cp, aes(x = x, y = RR, ymin = RRlow, ymax = RRhigh)) +
geom_hline(yintercept = 1, linetype = '11') +
theme_classic() +
geom_ribbon(fill = 'grey75', alpha = 0.2) +
geom_line()
m1 <- single_zone(exposure_matrix = boston_exposure_mat,
outcomes = boston_deaths)
plot_cp = data.frame(
x = m1$predvar,
RR = m1$allRRfit,
RRlow = m1$allRRlow,
RRhigh = m1$allRRhigh
)
ggplot(plot_cp, aes(x = x, y = RR, ymin = RRlow, ymax = RRhigh)) +
geom_hline(yintercept = 1, linetype = '11') +
theme_classic() +
geom_ribbon(fill = 'grey75', alpha = 0.2) +
geom_line() + xlab("Tmax (degC)")
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
devtools::load_all()
m1 <- single_zone(exposure_matrix = boston_exposure_mat,
outcomes = boston_deaths)
plot_cp = data.frame(
x = m1$predvar,
RR = m1$allRRfit,
RRlow = m1$allRRlow,
RRhigh = m1$allRRhigh
)
ggplot(plot_cp, aes(x = x, y = RR, ymin = RRlow, ymax = RRhigh)) +
geom_hline(yintercept = 1, linetype = '11') +
theme_classic() +
geom_ribbon(fill = 'grey75', alpha = 0.2) +
geom_line() + xlab("Tmax (degC)")
devtools::build_vignettes()
roxygen2::roxygenise()
roxygen2::roxygenise()
devtools::load_all()
devtools::build_vignettes()
devtools::document()
devtools::load_all()
devtools::build_vignettes()
devtools::document()
rstantools::rstan_config()
devtools::document()
devtools::load_all()
devtools::build_vignettes()
m_sub <- gnm(daily_deaths ~ cb,
data = boston_deaths_comb,
family = quasipoisson,
eliminate = factor(strata),
subset = keep == 1)
summary(m_sub)
stratum_vector <- boston_deaths$strata
stratum_vector <- factor(boston_deaths$strata, labels = 1:n_strata)
# replace stratum_vector with counts
n_strata <- length(unique(stratum_vector))
stratum_vector <- factor(boston_deaths$strata, labels = 1:n_strata)
stratum_vector
stratum_vector <- as.numeric(factor(boston_deaths$strata, labels = 1:n_strata))
stratum_vector
X <- as.matrix(cb)
beta <- coef(m_sub)
beta
y <- boston_deaths$daily_deaths
# get dims of X
N = nrow(X)
K = ncol(X)
# replace stratum_vector with counts
n_strata <- length(unique(stratum_vector))
stratum_vector <- as.numeric(factor(boston_deaths$strata, labels = 1:n_strata))
# sum observed and predicted counts per stratum
sum_y_stratum    = rep(0, n_strata)
sum_pred_stratum = rep(0, n_strata)
xBeta_out = exp(X %*% beta)
for (n in 1:N) {
s = stratum_vector[n]
sum_y_stratum[s] = sum_y_stratum[s] + y[n]
sum_pred_stratum[s] = sum_pred_stratum[s] + xBeta_out[n]
}
# rescale predictions so that the sum of the predicted in each group
# equals the sum of the observed in each group
pred_rescaled <- rep(NA, N)
for (n in 1:N) {
s = stratum_vector[n]
pred_rescaled[n] = xBeta_out[n] * sum_y_stratum[s] / sum_pred_stratum[s]
}
# compute pearson chi-squared
pearson_x2 = NA;
for (n in 1:N) {
pearson_x2 = pearson_x2 + (y[n] - pred_rescaled[n])^2 / pred_rescaled[n]
}
# calculate dispersion
df_resid = N - K - n_strata
dispersion = pearson_x2 / df_resid
dispersion
pred_rescaled
pearson_x2
pred_rescaled
any(is.na(pred_rescaled))
# compute pearson chi-squared
pearson_x2 = NA;
for (n in 1:N) {
pearson_x2 = pearson_x2 + (y[n] - pred_rescaled[n])^2 / pred_rescaled[n]
}
pearson_x2
# compute pearson chi-squared
pearson_x2 = 0;
for (n in 1:N) {
pearson_x2 = pearson_x2 + (y[n] - pred_rescaled[n])^2 / pred_rescaled[n]
}
pearson_x2
# calculate dispersion
df_resid = N - K - n_strata
dispersion = pearson_x2 / df_resid
dispersion
# get vcov by inverting Fisher information matrix for
# a quasipoisson regression
exp_beta_x <- exp(X %*% beta)
exp_beta_x_mat <- matrix(exp_beta_x,
ncol = ncol(X),
nrow = nrow(X), byrow = F)
head(exp_beta_x_mat)
head(exp_beta_x_mat)
mu_X <- exp_beta_x_mat * X
head(mu_X)
any(is.na(mu_X))
# MINVERSE(MMULT(TRANSPOSE(AH8:AV130),R8:AF130))
test_vcov <- MASS::ginv(t(mu_X) %*% X)
test_vcov
test_vcov * dispersion
vcov(m_sub)
# get vcov by inverting Fisher information matrix for
# a quasipoisson regression
exp_beta_x <- exp(X %*% beta)
head(exp_beta_x_mat)
mu_X <- exp_beta_x_mat * X
head(mu_X)
any(is.na(mu_X))
# MINVERSE(MMULT(TRANSPOSE(AH8:AV130),R8:AF130))
test_vcov <- MASS::ginv(t(mu_X) %*% X)
test_vcov
test_vcov * dispersion
# get vcov by inverting Fisher information matrix for
# a quasipoisson regression
# Linear predictor
eta <- as.vector(X %*% beta)
# Mean
mu <- exp(eta)
# Weight matrix
W <- diag(mu)
# Fisher information
XtWX <- t(X) %*% W %*% X
# Variance-covariance matrix
vcov_beta <- solve(XtWX)
vcov_beta
vcov_beta * dispersion
fit <- glm(y ~ X - 1, family = poisson())
all.equal(vcov(fit), vcov_beta, tolerance = 1e-8)
vcov(fit)
fit <- glm.fit(
x = X,
y = y,
family = poisson()
)
all.equal(vcov(fit), vcov_beta, tolerance = 1e-8)
vcov(fit)
fit
fit <- glm(
x = X,
y = y,
family = poisson()
)
fit <- glm(y ~ X + 0, family = poisson())
all.equal(vcov(fit), vcov_beta, tolerance = 1e-8)
fit
beta
fit <- glm(y ~ X + 0, family = quasipoisson())
fit
I <- matrix(0, ncol(X), ncol(X))
I <- matrix(0, ncol(X), ncol(X))
n_strata <- length(unique(stratum_vector))
stratum_vector <- as.numeric(factor(boston_deaths$strata, labels = 1:n_strata))
s = 1
idx <- which(stratum_vector == s)
Xs <- X[idx, , drop = FALSE]
eta <- as.vector(Xs %*% beta)
ps <- exp(eta)
ps <- ps / sum(ps)
Ns <- sum(y[idx])
Ws <- diag(ps) - tcrossprod(ps)
I <- I + Ns * t(Xs) %*% Ws %*% Xs
for (s in 1:n_strata) {
idx <- which(stratum_vector == s)
Xs <- X[idx, , drop = FALSE]
eta <- as.vector(Xs %*% beta)
ps <- exp(eta)
ps <- ps / sum(ps)
Ns <- sum(y[idx])
Ws <- diag(ps) - tcrossprod(ps)
I <- I + Ns * t(Xs) %*% Ws %*% Xs
}
vcov_beta <- solve(I)
vcov_beta
vcov_beta * dispersioin
vcov_beta * dispersion
vcov(m_sub)
# --- loop over strata -------------------------------------------------------
for (s in seq_len(n_strata)) {
# Indices for stratum s
idx <- which(strata == s)
# Skip degenerate strata
if (length(idx) <= 1) next
# Design matrix for stratum s
Xs <- X[idx, , drop = FALSE]
# Linear predictor
eta <- as.vector(Xs %*% beta)
# Multinomial probabilities
ps <- exp(eta)
ps <- ps / sum(ps)
# Total count in stratum s
Ns <- sum(y[idx])
# Multinomial covariance matrix
Ws <- diag(ps) - tcrossprod(ps)
# Add the Fisher information contribution from stratum s
#
# Multinomial Fisher information:
# I_s = Ns * X_s^T Ws X_s
#
# Ns scales the information by the total count in the stratum
I <- I + Ns * t(Xs) %*% Ws %*% Xs
}
# --- loop over strata -------------------------------------------------------
for (s in seq_len(n_strata)) {
# Indices for stratum s
idx <- which(stratum_vector == s)
# Skip degenerate strata
if (length(idx) <= 1) next
# Design matrix for stratum s
Xs <- X[idx, , drop = FALSE]
# Linear predictor
eta <- as.vector(Xs %*% beta)
# Multinomial probabilities
ps <- exp(eta)
ps <- ps / sum(ps)
# Total count in stratum s
Ns <- sum(y[idx])
# Multinomial covariance matrix
Ws <- diag(ps) - tcrossprod(ps)
# Add the Fisher information contribution from stratum s
#
# Multinomial Fisher information:
# I_s = Ns * X_s^T Ws X_s
#
# Ns scales the information by the total count in the stratum
I <- I + Ns * t(Xs) %*% Ws %*% Xs
}
ginv(I)
MASS::ginv(I)
solve(I)
solve(I) * dispersion
# Recode strata as consecutive integers 1, ..., S
n_strata <- length(unique(stratum_vector))
stratum_vector <- as.numeric(factor(stratum_vector, labels = 1:n_strata))
# Initialize Fisher information matrix
p <- ncol(X)
I <- matrix(0, p, p)
# --- loop over strata -------------------------------------------------------
for (s in seq_len(n_strata)) {
# Indices for stratum s
idx <- which(strata == s)
# Skip degenerate strata
if (length(idx) <= 1) next
# Design matrix for stratum s
Xs <- X[idx, , drop = FALSE]
# Linear predictor
eta <- as.vector(Xs %*% beta)
# Multinomial probabilities
ps <- exp(eta)
ps <- ps / sum(ps)
# Total count in stratum s
Ns <- sum(y[idx])
# Multinomial covariance matrix
Ws <- diag(ps) - tcrossprod(ps)
# Fisher information contribution
I <- I + Ns * crossprod(Xs, Ws %*% Xs)
}
# --- loop over strata -------------------------------------------------------
for (s in seq_len(n_strata)) {
# Indices for stratum s
idx <- which(stratum_vector == s)
# Skip degenerate strata
if (length(idx) <= 1) next
# Design matrix for stratum s
Xs <- X[idx, , drop = FALSE]
# Linear predictor
eta <- as.vector(Xs %*% beta)
# Multinomial probabilities
ps <- exp(eta)
ps <- ps / sum(ps)
# Total count in stratum s
Ns <- sum(y[idx])
# Multinomial covariance matrix
Ws <- diag(ps) - tcrossprod(ps)
# Fisher information contribution
I <- I + Ns * crossprod(Xs, Ws %*% Xs)
}
solve(I)
ginv(I)
MASS::ginv(I)
devtools::document()
devtools::load_all()
calc_dispersion(boston_deaths$daily_deaths, X = cb,
stratum_vector = boston_deaths$strata)
calc_dispersion(boston_deaths$daily_deaths, X = cb,
stratum_vector = boston_deaths$strata,
beta = coef(m_sub))
vcov_beta <- calc_vcov(X = cb, beta = coef(m_sub),
stratum_vector = boston_deaths$strata)
devtools::load_all()
calc_dispersion(boston_deaths$daily_deaths,
X = cb,
stratum_vector = boston_deaths$strata,
beta = coef(m_sub))
vcov_beta <- calc_vcov(X = cb, beta = coef(m_sub),
stratum_vector = boston_deaths$strata)
all.equal(vcov_beta * dispersion, vcov(m_sub))
vcov_beta
all.equal(vcov_beta * dispersion, as.matrix(vcov(m_sub)))
as.matrix(vcov(m_sub))
vcov_beta * dispersion
all.equal(vcov_beta * dispersion, as.matrix(vcov(m_sub)), tolerance = 1e-8)
all.equal(vcov_beta * dispersion, unname(vcov(m_sub)), tolerance = 1e-8)
vcov_beta <- calc_vcov(X = cb, beta = coef(m_sub),
stratum_vector = boston_deaths$strata)
all.equal(vcov_beta * dispersion, unname(vcov(m_sub)), tolerance = 1e-8)
t1 <- vcov_beta * dispersion
t2 <- matrix(vcov(m_sub))
t2
t2 <- as.matrix(vcov(m_sub))
t2
dimnames(t2)
dimnames(t2) <- NULL
t2
all.equal(vcov_beta * dispersion, unname(vcov(m_sub)), tolerance = 1e-8)
all.equal(t1, t2, tolerance = 1e-8)
t2
t1
all.equal(t1, t2, tolerance = 1e-8)
attributes(t1)
attributes(t2)
vcov(m_sub)
xx <- vcov(m_sub)
t2 <- unclass(as.matrix(vcov(m_sub)))
all.equal(t1, t2, tolerance = 1e-8)
t2
attributes(t2) <- NULL
all.equal(t1, t2, tolerance = 1e-8)
t2
t2 <- matrix(t2, nrow = nrow(t1), ncol = ncol(t1))
t2
all.equal(t1, t2, tolerance = 1e-8)
devtools::document()
devtools::build_vignettes()
devtools::load_all()
devtools::load_all()
roxygen2::roxygenise()
devtools::load_all()
devtools::build_vignettes()
devtools::document()
devtools::load_all()
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
devtools::document()
devtools::document()
pkgload::dev_help('calc_vcov')
pkgload::dev_help('calc_dispersion')
pkgload::dev_help('single_zone')
