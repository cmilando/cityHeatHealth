---
title: "Using Spatial Bayesian methods in `cityHeatHealth`"
output:
  rmarkdown::html_vignette:
    fig.retina: 2
    dev: svg
vignette: >
  %\VignetteIndexEntry{Using Spatial Bayesian methods in `cityHeatHealth`}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(cityHeatHealth)
```

Another way that this model can be solved is by using Bayesian inference, implemented in STAN. We are including this implementation here so that it makes sense why we are including it later on. 

The innovation here is combining the method of Armstrong 2014 with a spatial method, in this case BYM2 

We implemented the spatial bayesian method of BYM2 but instead of regular poisson as a conditional poisson (i.e., multinomial) which has performance gains that they articulate in Amrstrong.

This requires bringing in a shapefile, so you can define the network 

The standard application is using MCMC

You can also experiment with speeding things up (at the risk of less precise estimates) using the laplace or variational method. see Jack's notes as so what is going on here

```{r setup2, fig.height=3, fig.width=5}
data("ma_exposure")
data("ma_deaths")

# create exposure matrix
exposure_columns <- list(
  "date" = "date",
  "exposure" = "tmax_C",
  "geo_unit" = "TOWN20",
  "geo_unit_grp" = "COUNTY20"
)

TOWNLIST <- c('CHELSEA', 'EVERETT', 'REVERE', 'MALDEN')

exposure <- subset(ma_exposure, TOWN20 %in%  TOWNLIST &
                     year(date) %in% 2012:2015)
exposure_mat <- make_exposure_matrix(exposure, exposure_columns)

# create outcome table
outcome_columns <- list(
  "date" = "date",
  "outcome" = "daily_deaths",
  "factor" = 'age_grp',
  "factor" = 'sex',
  "geo_unit" = "TOWN20",
  "geo_unit_grp" = "COUNTY20"
)
deaths   <- subset(ma_deaths, TOWN20 %in%  TOWNLIST & 
                     year(date) %in% 2012:2015)
deaths_tbl <- make_outcome_table(deaths,  outcome_columns)

# plot
data("ma_towns")

library(ggplot2)
local_shp <- subset(ma_towns, TOWN20 %in%  TOWNLIST)
ggplot(local_shp) + geom_sf(aes(fill = TOWN20))
```

Now get initial estimates for each `geo_unit`
```{r b2}
beta_l <- vector("list", 4) 
cr_l <- vector("list", 4) 
plot_l <- vector("list", 4)

cb_list <- vector("list", 4)
oo_list <- vector("list", 4)

for(bb in 1:4) {
  m1 <- condPois_1stage(
    subset(exposure_mat, TOWN20 == TOWNLIST[bb]),
    subset(deaths_tbl, TOWN20 == TOWNLIST[bb]))
  
  cb_list[[bb]] <- m1$`_`$out[[1]]$orig_basis
  oo_list[[bb]] <- m1$`_`$out[[1]]$outcomes
  
  beta_l[[bb]] <- m1$`_`$out[[1]]$orig_coef
  
  cr_l[[bb]] <- m1$`_`$out[[1]]$coef
  
  plot_l[[bb]] <- plot(m1)
  
}
do.call(cbind, beta_l) # COEFS NOT THE SAME
do.call(cbind, cr_l)   # COEFS THE SAME
library(patchwork)
wrap_plots(plot_l)
```


the cr coefs are similar
the orig_coefs are not, which is why SBDLNM method doesn't work

So, instead of forcing Beta to be similar, we can use bym2

refs:
 
 * https://mc-stan.org/learn-stan/case-studies/icar_stan.html
 * https://link.springer.com/article/10.1186/1476-072X-4-31
 * https://github.com/stan-dev/example-models/blob/e5b7d9e2e9ecc375805c7e49e4a4d4c1882b5e3b/knitr/car-iar-poisson/bym2_predictor_plus_offset.stan#L4 

ok here's the ref of how LAPLACE works:

* https://mc-stan.org/cmdstanr/reference/model-method-laplace.html
* https://statmodeling.stat.columbia.edu/2023/02/08/implementing-laplace-approximation-in-stan-whats-happening-under-the-hood/

I think this makes for a good candidate because betas are normal and the model is not hierarchical

  # and here https://discourse.mc-stan.org/t/r-package-using-cmdstanr/32758
  # stan_file <- system.file("stan", "SB_CondPoisson.stan",
  #                          package = "cityHeatHealth")
  #
  # mod <- cmdstanr::cmdstan_model(stan_file,
  #    

```{r b3}
m_sb1 <- condPois_sb(exposure_mat, deaths_tbl, local_shp, 
                     stan_type = 'mcmc',
                     verbose = 2,
                     use_spatial_model = T)

```

Compare 
```{r compare2}
do.call(cbind, beta_l)

m_sb1$`_`$beta_mat
```


